Datos importantes sobre el port actual:

- Podemos tener varios procesos en ejecución en el shell 
  con background &
- En config/Configuration necesitamos al menos NPROC 4

TODO
----

- sleep usa sleepms. Como tenemos interrupciones cada 100ms
y como qkey en queue.h es char (originalmente es int32, pero 
con int32 nos quita muchisima RAM) tenemos un hack/workaround
para lograr el sleepms acorde, pero no es en ms.
SOLUCIONAR.
- ademas como las key en queue son char, podemos tener
sleep de maximo 20 segundos aprox. (de la llamada 20*10ms de sleep100ms())

- agregar a la tabla de cmdtab del shell que pueda indicar
el stack para cada proceso.

- agregar al help la ayuda de si el programa es un comando 
interno al shell o externo.

- agregar el eeprom fs

- 




Demas
-----

BASIC: https://github.com/robinhedwards/ArduinoBASIC/blob/master/arduino_BASIC.ino

Si en include/shell.c achicamos maxtokens podemos achicar la cantidad
de memoria que necesita el shell en create() en initialice()
Por ejemplo, podemos rescatar 56 bytes si tokens maximo son 5.


Vamos a usar los startupfiles y el ldscript de avr-gcc

para poder llamar a nulluser agregamos la sección init8
en system/start.S



la ram empieza en 0x800100 (en realidad parece empezar en
0x800060, pero el linker de avr-gcc pone esa dirección porque al parecer
en el 0x800060 hay registros.



uart: vamos a poner un serial_avr.c con el manejador de interrupciones
en recepción, tambien putc, e init.

En el device tty se utiliza mucho entremezclado el manejador del uart
(para stm32). 
Vamos a dejarlo por ahora, y cada vez que se llame
a enviar un dato llamaremos a putc de nuestro driver serial.


UART:
tenemos 
ttykickout
ttyhandle_out
ttyhandle_in
ttyhandler (un solo argumento).

Intentaremos mandar a ttyhandler otro argumento, c (char) recibido.
Entonces lo llamaremos desde la rutina de atencion de interrupciones del 
uart RX (recepcion). Enviando el char c, y un flag para indicar recepcion.

Para enviar al parecer el software termina produciendo una interrupcion
forzada con ttykickout. Antes al forzar la interrupción se llamaba
tambien a ttyhandler.
Nosotros podemos intentar llamar a ttyhandler forzadamente desde 
ttykickout. Con el flag de envío como argumento.





Memory
------

Hay un gran bolonqui con la memoria (gestor de memoria de Xinu y AVR).
En AVR los punteros son de 16bits. Pero, la direcciones de SRAM son de al
menos 3 bytes (arranca en 0x800100); 
 
En la inicialización hay que prestar atención:
- O convertimos todos los punteros a unsigned long * (en avr long es de 32bits);
- o cada vez que se usa ese puntero se castea a unsigned long *, y se le 
suma 0x800000;

Además hay que ver que a veces no use uint32 para algún calculo intermedio.
No daría problemas si no le sumamos previamente 0x800000, y si en su 
utilización final. 

ACLARACION: los punteros de 16bits están bien para ser usados.
Ahí no debería haber problemas.
El problema puede surgir unicamente cuando se hace cast de las direcciones
de 32bits a 16bits.



Gestion de procesos


resched.c
create.c

- copiar context switch de xinu-Avr a xinu-avr
- En la estructura procent hay que poner los elementos registros que
estan en el viejo xinu avr.o

En create.c hay que inicializar esos elementos registros de la estructura
struct procent . 
En el viejo xinu se llaman pregs[]

En el resched.c nuevo hay que poner la llamada a ctxswitch.




BASIC: https://github.com/robinhedwards/ArduinoBASIC/blob/master/arduino_BASIC.ino
En 
#define STACK_SIZE (sizeof(struct stack_for_frame)*2)
estaba en *5  en vez de *2
Pero pisaba memoria de datos. Y con 2 no anda bien.

