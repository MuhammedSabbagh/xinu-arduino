
Vamos a usar los startupfiles y el ldscript de avr-gcc

para poder llamar a nulluser agregamos la sección init8
en system/start.S



la ram empieza en 0x800100 (en realidad parece empezar en
0x800060, pero el linker de avr-gcc pone esa dirección porque al parecer
en el 0x800060 hay registros.



uart: vamos a poner un serial_avr.c con el manejador de interrupciones
en recepción, tambien putc, e init.

En el device tty se utiliza mucho entremezclado el manejador del uart
(para stm32). 
Vamos a dejarlo por ahora, y cada vez que se llame
a enviar un dato llamaremos a putc de nuestro driver serial.


UART:
tenemos 
ttykickout
ttyhandle_out
ttyhandle_in
ttyhandler (un solo argumento).

Intentaremos mandar a ttyhandler otro argumento, c (char) recibido.
Entonces lo llamaremos desde la rutina de atencion de interrupciones del 
uart RX (recepcion). Enviando el char c, y un flag para indicar recepcion.

Para enviar al parecer el software termina produciendo una interrupcion
forzada con ttykickout. Antes al forzar la interrupción se llamaba
tambien a ttyhandler.
Nosotros podemos intentar llamar a ttyhandler forzadamente desde 
ttykickout. Con el flag de envío como argumento.





Memory
------

Hay un gran bolonqui con la memoria (gestor de memoria de Xinu y AVR).
En AVR los punteros son de 16bits. Pero, la direcciones de SRAM son de al
menos 3 bytes (arranca en 0x800100); 
 
En la inicialización hay que prestar atención:
- O convertimos todos los punteros a unsigned long * (en avr long es de 32bits);
- o cada vez que se usa ese puntero se castea a unsigned long *, y se le 
suma 0x800000;

Además hay que ver que a veces no use uint32 para algún calculo intermedio.
No daría problemas si no le sumamos previamente 0x800000, y si en su 
utilización final. 

ACLARACION: los punteros de 16bits están bien para ser usados.
Ahí no debería haber problemas.
El problema puede surgir unicamente cuando se hace cast de las direcciones
de 32bits a 16bits.



